"use strict";

require("./indexeddb-fill.js");

const { expect } = require("chai");
const sinon = require("sinon");

const {
  ArrayTable,
  CompositeUnion,
  Expression,
  GroupBy,
  IDBTable,
  Join,
  NamedRelation,
  OrderBy,
  Write,
  Select,
  TermGroups,
  Where,
  eliminateCommon,
  joinSchema,
  hoistPredicates,
  parseExpression,
  prepareTransaction,
  propagateKeyRanges,
  traversePath,
  unknownDependency
} = require("..");


describe("Optimize", function() {
  let arrayS, arrayT;
  let namedS, namedT;

  beforeEach(function() {
    let data = [1, 2];
    arrayS = new ArrayTable(data);
    namedS = new NamedRelation(arrayS, "s");
    arrayT = new ArrayTable(data);
    namedT = new NamedRelation(arrayT, "t");
  })

  describe("Hoisting", function() {
    it("hoists Where predicate to NamedRelation", function() {
      let termGroups = new TermGroups();
      termGroups.parse("s.id == 1", {s: namedS});
      let where = new Where(namedS, termGroups);

      expect(hoistPredicates(where)).to.equal(namedS);
      expect(namedS.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, 1) === 0"]);
    })

    it("hoists Where predicate to left NamedRelation of inner Join", function() {
      let termGroups = new TermGroups();
      termGroups.parse("s.id == 1", {s: namedS});
      let join = new Join(namedS, namedT);
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(join.predicates).to.deep.equal([]);
      expect(namedS.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, 1) === 0"]);
      expect(namedT.predicates).to.deep.equal([]);
    })

    it("hoists Where predicate to left NamedRelation of inner Join", function() {
      let termGroups = new TermGroups();
      termGroups.parse("s.id == 1", {s: namedS});
      let join = new Join(namedS, namedT);
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(join.predicates).to.deep.equal([]);
      expect(namedS.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, 1) === 0"]);
      expect(namedT.predicates).to.deep.equal([]);
    })

    it("hoists Where predicate to right NamedRelation of inner Join", function() {
      let termGroups = new TermGroups();
      termGroups.parse("t.id == 1", {t: namedT});
      let join = new Join(namedS, namedT);
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(join.predicates).to.deep.equal([]);
      expect(namedS.predicates).to.deep.equal([]);
      expect(namedT.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(t.id, 1) === 0"]);
    })

    it("hoists Where predicate to right NamedRelation of inner Join even if it depends on left and right", function() {
      // The left tuple is available when evaluating the right predicate.
      let termGroups = new TermGroups();
      termGroups.parse("t.id == s.id", {s: namedS, t: namedT});
      let join = new Join(namedS, namedT);
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(join.predicates).to.deep.equal([]);
      expect(namedS.predicates).to.deep.equal([]);
      expect(namedT.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(t.id, s.id) === 0"]);
    })

    it("hoists Where predicate to left NamedRelation of outer Join", function() {
      let termGroups = new TermGroups();
      termGroups.parse("s.id == 1", {s: namedS});
      let join = new Join(namedS, namedT, "outer");
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(namedS.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, 1) === 0"]);
      expect(namedT.predicates).to.deep.equal([]);
    })

    it("generally, does not hoist Where predicate to right NamedRelation of outer Join", function() {
      // The predicate might depend on whether a tuple is generated by the join.
      let termGroups = new TermGroups();
      termGroups.parse("t.id === undefined", {t: namedT});
      let join = new Join(namedS, namedT, "outer");
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(namedS.predicates).to.deep.equal([]);
      expect(namedT.predicates).to.deep.equal([]);
      expect(join.predicates.map(p => p.tree())).to.deep.equal(["t.id === undefined"]);
    })

    it("for terms that may be expressed as ranges only, hoists Where predicate to right NamedRelation of outer Join", function() {
      // Range expressions cannot distinguish whether a tuple is generated.
      let termGroups = new TermGroups();
      termGroups.parse("t.id == s.id", {s: namedS, t: namedT});
      let join = new Join(namedS, namedT, "outer");
      let where = new Where(join, termGroups);
      
      expect(hoistPredicates(where)).to.equal(join);
      expect(namedS.predicates).to.deep.equal([]);
      expect(namedT.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(t.id, s.id) === 0"]);
    })

    it("does not hoist Where predicate above GroupBy that it filters", function() {
      // i.e. the Where is being used like an sql HAVING clause.
      let selector = parseExpression("{id: s.id}", {s: namedS});
      let grouper = parseExpression("[s.id]", {s: namedS});
      let groupBy = new GroupBy(namedS, selector, grouper);

      let termGroups = new TermGroups();
      termGroups.parse("id == 1", undefined);
      let predicate = Array.from(termGroups.terms.values())[0].expression;

      let where = new Where(groupBy, termGroups);
      
      expect(hoistPredicates(where)).to.equal(where);
      expect(where.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(id, 1) === 0"]);
      expect(namedS.predicates).to.deep.equal([]);
    })

    it("hoists Join predicates that depend on only left relation to NamedRelation", function() {
      let joinST = new Join(namedS, namedT);
      joinST.termGroups.parse("s.id == 1", {s: namedS});
      
      expect(hoistPredicates(joinST)).to.equal(joinST);
      expect(namedS.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, 1) === 0"]);
      expect(namedT.predicates).to.deep.equal([]);      
    })

    it("hoists Join predicates that depend on only right relation to NamedRelation", function() {
      let joinST = new Join(namedS, namedT);
      joinST.termGroups.parse("t.id == 1", {t: namedT});
      
      expect(hoistPredicates(joinST)).to.equal(joinST);
      expect(namedS.predicates).to.deep.equal([]);      
      expect(namedT.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(t.id, 1) === 0"]);
    })

    it("hoists Join predicates that depend on both left and right relation to right", function() {
      let joinST = new Join(namedS, namedT);
      joinST.termGroups.parse("s.id == t.id", {s: namedS, t: namedT});
      
      expect(hoistPredicates(joinST)).to.equal(joinST);
      expect(namedS.predicates).to.deep.equal([]);      
      expect(namedT.predicates.map(p => p.tree())).to.deep.equal(["$$cmp(s.id, t.id) === 0"]);
    })

    it("hoists Where key ranges to NamedRelation", function() {
      let termGroups = new TermGroups();
      termGroups.parse("s.id == 1", {s: namedS});
      let where = new Where(namedS, termGroups);

      expect(hoistPredicates(where)).to.equal(namedS);
      expect(namedS.keyRanges.id.tree()).to.deep.equal({
        class: "RangeExpression",
        lower: "1",
        upper: "1",
      });
    })

    it("merges Where key ranges to NamedRelation", function() {
      let termGroups1 = new TermGroups();
      termGroups1.parse("s.id >= 1", {s: namedS});
      let where1 = new Where(namedS, termGroups1);

      let termGroups2 = new TermGroups();
      termGroups2.parse("s.id <= 2", {s: namedS});
      let where2 = new Where(where1, termGroups2);

      expect(hoistPredicates(where2)).to.equal(namedS);
      expect(namedS.keyRanges.id.tree()).to.deep.equal({
        class: "RangeIntersection",
        left: {
          class: "RangeExpression",
          upper: "2",
        },
        right: {
          class: "RangeExpression",
          lower: "1",
        },
      });
    })

    it("merges OrderBy", function() {
      let termGroups = new TermGroups();
      
      let ordering1 = { expression: parseExpression("s.id == 1", {s: namedS}), order: 1 };
      let orderBy1 = new OrderBy(namedS, [ordering1]);
      let ordering2 = { expression: parseExpression("s.id == 1", {s: namedS}), order: -1 };
      let orderBy2 = new OrderBy(orderBy1, [ordering2]);

      expect(hoistPredicates(orderBy2)).to.equal(orderBy2);
      expect(orderBy2.relation).to.equal(namedS);
      expect(orderBy2.ordering).to.deep.equal([ordering1, ordering2]);
    })
  })

  describe("Analyze transaction", function() {
    it("adds transaction node for table names of IDBTable nodes", function() {
      let db = {};
      let table = new IDBTable(db, "employee");
      let named = new NamedRelation(table, "e");

      let analyzed = prepareTransaction(named);
      expect(analyzed.tree()).to.deep.equal({
        class: "IDBTransaction",
        tableNames: ["employee"],
        relation: "e",
        mode: "readonly",
      });
    })

    it("adds readwrite transaction node if there are any Write nodes", function() {
      let db = {};
      let table = new IDBTable(db, "employee");
      let named = new NamedRelation(table, "e");
      let write = new Write(named, table, {});

      let analyzed = prepareTransaction(write);
      expect(analyzed.tree()).to.deep.equal({
        class: "IDBTransaction",
        relation: {
          class: "Write",
          options: {},
          relation: "e",
          table: {
            "class": "IDBTable",
          },
        },
        tableNames: ["employee"],
        mode: "readwrite",
      });
    })

    it("does not add transaction node if no IDBTable nodes", function() {
      let table = new ArrayTable([]);
      let named = new NamedRelation(table, "e");

      let analyzed = prepareTransaction(named);
      expect(analyzed.tree()).to.deep.equal("e");
    })

    it("throws if IDBTables from multiple databases accessed", function() {
      let db1 = {};
      let table1 = new IDBTable(db1, "employee");
      let named1 = new NamedRelation(table1, "e");
      let db2 = {};
      let table2 = new IDBTable(db2, "invoice");
      let named2 = new NamedRelation(table2, "i");
      let join = new Join(named1, named2);

      expect(function() {
        prepareTransaction(join);
      }).to.throw(/database/);
    })
  })
})
